<!-- ctg_display_optionA.html
     GitHub-ready single-file display.

     Option A implemented:
      - Mode latch (TOCO vs IUPC) driven by DISP|MODE or MC|IUPC
      - Hard reset on DISP|RESET / START / STOP / mode changes
      - Contractions visible (TOCO 0-100% or IUPC mmHg 0-100 scale mapped)
      - Removes "backwards L" artifact by resetting buffers/cursors correctly
      - Multi-baby lanes: renders up to 3 fetuses by index (0..2) by default
      - No speed hacks: fixed scroll step per sample; realism comes from incoming sample cadence
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CTG / TOCO / IUPC Display (Option A)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#0b0f14; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position:relative; width:100vw; height:100vh; }
    canvas { position:absolute; left:0; top:0; width:100%; height:100%; image-rendering: auto; }
    #hud {
      position:absolute; left:12px; top:10px;
      padding:8px 10px; border-radius:10px;
      background:rgba(0,0,0,.35); backdrop-filter: blur(4px);
      font-size:12px; line-height:1.35;
      max-width: 70vw;
      user-select:none;
      pointer-events:none;
      white-space:nowrap;
    }
    #hud b { font-weight:700; }
    #hud .dim { opacity:.75; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div id="hud">
    <div><b>Mode:</b> <span id="mode">TOCO</span> <span class="dim" id="submode"></span></div>
    <div><b>Patient:</b> <span id="patient">—</span> <span class="dim" id="ga"></span></div>
    <div><b>FHR:</b> <span id="fhrReadout">—</span></div>
    <div><b>UC:</b> <span id="ucReadout">—</span></div>
  </div>
</div>

<script>
/* -----------------------------
   Core state + buffers
-------------------------------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

function resize() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

const ui = {
  mode: document.getElementById('mode'),
  submode: document.getElementById('submode'),
  patient: document.getElementById('patient'),
  ga: document.getElementById('ga'),
  fhrReadout: document.getElementById('fhrReadout'),
  ucReadout: document.getElementById('ucReadout'),
};

const state = {
  mode: "TOCO",      // "TOCO" or "IUPC"
  iupc: 0,
  patient: "—",
  weeks: null,
  running: false,

  // Latest values (for HUD display)
  fhr: { 0: null, 1: null, 2: null },
  uc: { toco: 0, mmhg: null, tone: null },

  // Buffers
  x: 0,
  step: 2,           // pixels per sample
  fhrBuf: [[],[],[]],// 3 lanes of y-values (screen coords)
  ucBuf: [],

  // layout
  pad: 18,
};

function hardReset(reason = "") {
  state.x = 0;
  state.fhrBuf = [[],[],[]];
  state.ucBuf = [];
  // keep latest values, but the trace resets
  state.running = (state.running && reason !== "STOP");
}

function setMode(modeStr) {
  const m = (modeStr || "").toUpperCase() === "IUPC" ? "IUPC" : "TOCO";
  if (state.mode !== m) {
    state.mode = m;
    state.iupc = (m === "IUPC") ? 1 : 0;
    ui.mode.textContent = state.mode;
    ui.submode.textContent = (state.mode === "IUPC") ? "(mmHg labels ON)" : "(grid only)";
    hardReset("MODE");
  } else {
    ui.mode.textContent = state.mode;
    ui.submode.textContent = (state.mode === "IUPC") ? "(mmHg labels ON)" : "(grid only)";
  }
}

/* -----------------------------
   Drawing helpers
-------------------------------- */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function drawGrid() {
  const w = window.innerWidth, h = window.innerHeight;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle = "#0b0f14";
  ctx.fillRect(0,0,w,h);

  // split panes: top = FHR, bottom = UC
  const mid = Math.floor(h * 0.68);

  // grid lines
  ctx.lineWidth = 1;

  // Major and minor spacing
  const minor = 10, major = 50;

  // FHR pane grid
  for (let x = 0; x <= w; x += minor) {
    ctx.strokeStyle = (x % major === 0) ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.04)";
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, mid); ctx.stroke();
  }
  for (let y = 0; y <= mid; y += minor) {
    ctx.strokeStyle = (y % major === 0) ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.04)";
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }

  // UC pane grid
  for (let x = 0; x <= w; x += minor) {
    ctx.strokeStyle = (x % major === 0) ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.04)";
    ctx.beginPath(); ctx.moveTo(x, mid); ctx.lineTo(x, h); ctx.stroke();
  }
  for (let y = mid; y <= h; y += minor) {
    ctx.strokeStyle = ((y-mid) % major === 0) ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.04)";
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }

  // pane divider
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, mid); ctx.lineTo(w, mid); ctx.stroke();

  // Y-axis labels:
  // FHR labels always shown; UC labels only in IUPC mode (Option A requirement)
  drawFhrLabels(mid);
  if (state.mode === "IUPC") drawIupcLabels(mid, h);
}

function drawFhrLabels(mid) {
  const w = window.innerWidth;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";

  // Map 30..240 bpm into top pane
  const bpmTicks = [30, 60, 90, 120, 150, 180, 210, 240];
  for (const bpm of bpmTicks) {
    const y = fhrToY(bpm, mid);
    ctx.fillText(String(bpm), 8, y);
  }

  // little title
  ctx.fillStyle = "rgba(255,255,255,0.60)";
  ctx.fillText("FHR (bpm)", 8, 14);
}

function drawIupcLabels(mid, h) {
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "12px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";

  // IUPC ticks in mmHg
  const mm = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
  for (const v of mm) {
    const y = ucToY(v, mid, h);
    ctx.fillText(String(v), 8, y);
  }

  ctx.fillStyle = "rgba(255,255,255,0.60)";
  ctx.fillText("IUPC (mmHg)", 8, mid + 14);
}

function fhrToY(bpm, mid) {
  const w = window.innerWidth;
  const pad = state.pad;
  // map 30..240 bpm into pad..(mid-pad)
  const lo = 30, hi = 240;
  const t = (clamp(bpm, lo, hi) - lo) / (hi - lo);
  return (mid - pad) - t * (mid - 2*pad);
}

function ucToY(value, mid, h) {
  const pad = state.pad;
  // UC pane: map 0..100 into (h-pad)..(mid+pad)
  const lo = 0, hi = 100;
  const t = (clamp(value, lo, hi) - lo) / (hi - lo);
  return (h - pad) - t * ((h - pad) - (mid + pad));
}

function laneOffsetY(mid, laneIdx) {
  // 3 lanes separated slightly inside the same FHR pane
  // lane 0 = center, lane 1 = slightly up, lane 2 = slightly down
  const offsets = [0, -18, 18];
  return offsets[laneIdx] || 0;
}

function drawTrace(points, strokeStyle) {
  const w = window.innerWidth;
  if (!points || points.length < 2) return;

  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 2;
  ctx.beginPath();

  // points are [{x,y}, ...]
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1; i<points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();
}

function rebuildPointsFromBuf(buf) {
  // buf is array of {x,y}. Ensure we only keep visible points.
  const w = window.innerWidth;
  const minX = 0, maxX = w;
  return buf.filter(p => p.x >= minX && p.x <= maxX);
}

function scrollIfNeeded() {
  const w = window.innerWidth;
  if (state.x <= w) return;

  // shift all points left by state.step, keep within viewport
  const dx = state.step;
  for (let i=0; i<3; i++) {
    state.fhrBuf[i] = state.fhrBuf[i].map(p => ({ x: p.x - dx, y: p.y }));
    state.fhrBuf[i] = rebuildPointsFromBuf(state.fhrBuf[i]);
  }

  state.ucBuf = state.ucBuf.map(p => ({ x: p.x - dx, y: p.y }));
  state.ucBuf = rebuildPointsFromBuf(state.ucBuf);

  state.x -= dx;
}

/* -----------------------------
   Ingest messages
-------------------------------- */
function updateHudReadouts() {
  const f = [];
  for (const idx of [0,1,2]) {
    const v = state.fhr[idx];
    if (v != null) f.push(`B${idx+1}:${v}`);
  }
  ui.fhrReadout.textContent = f.length ? f.join("  ") : "—";

  if (state.mode === "TOCO") {
    ui.ucReadout.textContent = `TOCO ${Math.round(state.uc.toco)}%`;
  } else {
    const mm = (state.uc.mmhg != null) ? Math.round(state.uc.mmhg) : "—";
    const tone = (state.uc.tone != null) ? Math.round(state.uc.tone) : "—";
    ui.ucReadout.textContent = `IUPC ${mm} mmHg (tone ${tone})`;
  }
}

function pushFhrSample(idx, bpm) {
  const h = window.innerHeight;
  const mid = Math.floor(h * 0.68);

  // add one sample at current x position
  const y = fhrToY(bpm, mid) + laneOffsetY(mid, idx);
  state.fhrBuf[idx].push({ x: state.x, y });
}

function pushUcSample(value0to100) {
  const h = window.innerHeight;
  const mid = Math.floor(h * 0.68);
  const y = ucToY(value0to100, mid, h);
  state.ucBuf.push({ x: state.x, y });
}

function parseMessage(msg) {
  const parts = String(msg || "").split("|");
  const prefix = parts[0] || "";

  // DISP control
  if (prefix === "DISP") {
    const cmd = (parts[1] || "").toUpperCase();

    if (cmd === "MODE") {
      setMode(parts[2] || "TOCO");
    } else if (cmd === "RESET") {
      setMode(parts[2] || state.mode);
      hardReset("RESET");
    } else if (cmd === "START") {
      state.running = true;
      hardReset("START");
    } else if (cmd === "STOP") {
      state.running = false;
      hardReset("STOP");
    }
    return;
  }

  // Main controller messages (tolerant)
  if (prefix === "MC") {
    const cmd = parts[1] || "";
    if (cmd === "IUPC") {
      const v = Number(parts[2] || 0);
      setMode(v ? "IUPC" : "TOCO");
    } else if (cmd === "PATIENT") {
      state.patient = parts[2] || "—";
      state.weeks = (parts[3] != null) ? Number(parts[3]) : null;
      ui.patient.textContent = state.patient;
      ui.ga.textContent = (state.weeks != null && !Number.isNaN(state.weeks)) ? `${state.weeks}w` : "";
    } else if (cmd === "CMD") {
      const sub = parts[2] || "";
      if (sub === "START_SIM") { state.running = true; hardReset("START"); }
      if (sub === "STOP_SIM")  { state.running = false; hardReset("STOP"); }
    }
    return;
  }

  // FHR messages:
  // Accept formats like:
  //  - FHR|UPDATE|idx|bpm|...
  //  - FHR|WAVE|idx|bpm|...
  //  - FHR|idx|bpm|... (fallback)
  if (prefix === "FHR") {
    let idx = 0, bpm = null;

    if (parts.length >= 4 && (parts[1] === "UPDATE" || parts[1] === "WAVE" || parts[1] === "DATA")) {
      idx = Number(parts[2] || 0);
      bpm = Number(parts[3]);
    } else if (parts.length >= 3) {
      idx = Number(parts[1] || 0);
      bpm = Number(parts[2]);
    }

    if (!Number.isNaN(idx) && bpm != null && !Number.isNaN(bpm)) {
      idx = clamp(idx, 0, 2);
      state.fhr[idx] = Math.round(bpm);
      pushFhrSample(idx, bpm);
      updateHudReadouts();
      // advance x once per "sample tick" if any waveform message arrives
      state.x += state.step;
      scrollIfNeeded();
    }
    return;
  }

  // Contraction messages:
  // Accept formats like:
  //  - CON|TOCO|pct
  //  - CON|IUPC|mmhg|tone
  //  - CON|VALUE|toco|mmhg|tone
  //  - CON|EVENT|PEAK|mmhg (fallback)
  if (prefix === "CON") {
    const t1 = (parts[1] || "").toUpperCase();

    if (t1 === "TOCO") {
      const pct = Number(parts[2] || 0);
      if (!Number.isNaN(pct)) {
        state.uc.toco = clamp(pct, 0, 100);
        if (state.mode === "TOCO") pushUcSample(state.uc.toco);
      }
    } else if (t1 === "IUPC") {
      const mmhg = Number(parts[2]);
      const tone = Number(parts[3]);
      if (!Number.isNaN(mmhg)) state.uc.mmhg = mmhg;
      if (!Number.isNaN(tone)) state.uc.tone = tone;

      if (state.mode === "IUPC" && !Number.isNaN(mmhg)) {
        // map realistic IUPC mmHg into 0..100 display scale
        // (0..100 shown; typical peaks 30–70, tone 10–20)
        pushUcSample(clamp(mmhg, 0, 100));
      }
    } else if (t1 === "VALUE") {
      // CON|VALUE|toco|mmhg|tone
      const toco = Number(parts[2]);
      const mmhg = Number(parts[3]);
      const tone = Number(parts[4]);

      if (!Number.isNaN(toco)) state.uc.toco = clamp(toco, 0, 100);
      if (!Number.isNaN(mmhg)) state.uc.mmhg = mmhg;
      if (!Number.isNaN(tone)) state.uc.tone = tone;

      if (state.mode === "TOCO" && !Number.isNaN(toco)) pushUcSample(state.uc.toco);
      if (state.mode === "IUPC" && !Number.isNaN(mmhg)) pushUcSample(clamp(mmhg, 0, 100));
    } else if (t1 === "EVENT") {
      // If we only get events, try to extract a numeric and plot it (fallback)
      // Example: CON|EVENT|PEAK|55
      for (let i = 2; i < parts.length; i++) {
        const num = Number(parts[i]);
        if (!Number.isNaN(num)) {
          if (state.mode === "TOCO") {
            // treat event numeric as % if TOCO
            state.uc.toco = clamp(num, 0, 100);
            pushUcSample(state.uc.toco);
          } else {
            state.uc.mmhg = num;
            pushUcSample(clamp(num, 0, 100));
          }
          break;
        }
      }
    }

    updateHudReadouts();
    // advance x for contraction messages too if they arrive without FHR
    state.x += state.step;
    scrollIfNeeded();
    return;
  }
}

/* -----------------------------
   Render loop
-------------------------------- */
function render() {
  drawGrid();

  // Draw waveforms
  // FHR: 3 babies, distinct strokes
  drawTrace(state.fhrBuf[0], "rgba(0, 255, 160, 0.95)");
  drawTrace(state.fhrBuf[1], "rgba(255, 210, 0, 0.95)");
  drawTrace(state.fhrBuf[2], "rgba(120, 170, 255, 0.95)");

  // UC trace
  drawTrace(state.ucBuf, "rgba(255, 90, 120, 0.95)");

  requestAnimationFrame(render);
}
setMode("TOCO");
hardReset("BOOT");
render();

/* -----------------------------
   SL bridge entrypoints
-------------------------------- */
window.SLReceiveEncoded = function(encoded) {
  try {
    const msg = decodeURIComponent(String(encoded || ""));
    parseMessage(msg);
  } catch (e) {
    // ignore
  }
};

// Optional: accept postMessage too (useful if you later change bridge approach)
window.addEventListener("message", (ev) => {
  try {
    if (typeof ev.data === "string") parseMessage(ev.data);
  } catch (e) {}
});
</script>
</body>
</html>
